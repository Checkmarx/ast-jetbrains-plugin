package com.checkmarx.intellij.realtimeScanners.customProblemWindow;

import com.checkmarx.intellij.Constants;
import com.checkmarx.intellij.realtimeScanners.dto.CxProblems;
import com.checkmarx.intellij.service.ProblemHolderService;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.editor.*;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.SimpleToolWindowPanel;
import com.intellij.openapi.util.Disposer;
import com.intellij.openapi.util.Iconable;
import com.intellij.openapi.vfs.LocalFileSystem;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiManager;
import com.intellij.ui.treeStructure.SimpleTree;
import javax.swing.*;
import javax.swing.Timer;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.event.*;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.List;
import com.intellij.ui.ColoredTreeCellRenderer;
import com.intellij.ui.SimpleTextAttributes;
import com.intellij.ui.content.Content;


public class VulnerabilityToolWindow extends SimpleToolWindowPanel implements Disposable {

    private final Project project;
    private final SimpleTree tree;
    private final DefaultMutableTreeNode rootNode;
    private static Map<String, Icon> severityToIcon;
    private final Content content;
    private final Timer timer;

    public VulnerabilityToolWindow(Project project, Content content) {
        super(true, true);
        this.project = project;
        this.tree = new SimpleTree();
        this.rootNode = new DefaultMutableTreeNode();
        tree.setModel(new javax.swing.tree.DefaultTreeModel(rootNode));
        tree.setCellRenderer(new IssueTreeRenderer(tree));
        tree.setRootVisible(false);
        this.content = content;
        String password = "Hello@123";

        add(new JScrollPane(tree), BorderLayout.CENTER);
        initSeverityIcons();

        tree.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 1) navigateToSelectedIssue();
            }

            @Override
            public void mousePressed(MouseEvent e) {
                handleRightClick(e);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                handleRightClick(e);
            }
        });

        timer = new Timer(1000, e -> updateTabTitle());
        timer.start();

        // Ensure proper disposal of timer
        Disposer.register(this, () -> timer.stop());

        // Subscribe to updates
        project.getMessageBus().connect(this)
                .subscribe(ProblemHolderService.ISSUE_TOPIC, new ProblemHolderService.IssueListener() {
                    @Override
                    public void onIssuesUpdated(Map<String, List<CxProblems>> issues) {
                        SwingUtilities.invokeLater(() -> refreshTree(issues));
                    }
                });
    }

    private void initSeverityIcons() {
        severityToIcon = new HashMap<>();
        severityToIcon.put(Constants.ASCA_CRITICAL_SEVERITY, AllIcons.General.Error);
        severityToIcon.put(Constants.ASCA_HIGH_SEVERITY, AllIcons.General.Error);
        severityToIcon.put(Constants.ASCA_MEDIUM_SEVERITY, AllIcons.General.Warning);
        severityToIcon.put(Constants.ASCA_LOW_SEVERITY, AllIcons.General.Information);
    }

    public void refreshTree(Map<String, List<CxProblems>> issues) {
        // Save expanded file node names (file paths)
        Set<String> expandedPathsSet = new java.util.HashSet<>();

        int rowCount = tree.getRowCount();
        for (int i = 0; i < rowCount; i++) {
            TreePath path = tree.getPathForRow(i);
            if (path != null && tree.isExpanded(path)) {
                Object lastNode = path.getLastPathComponent();
                if (lastNode instanceof DefaultMutableTreeNode) {
                    DefaultMutableTreeNode node = (DefaultMutableTreeNode) lastNode;
                    Object userObject = node.getUserObject();
                    if (userObject instanceof FileNodeLabel) {  // file path nodes
                        expandedPathsSet.add(((FileNodeLabel) userObject).filePath);
                    }
                }
            }
        }
        // Clear and rebuild tree
        rootNode.removeAllChildren();
        for (Map.Entry<String, List<CxProblems>> entry : issues.entrySet()) {
            String filePath = entry.getKey();
            String fileName = getSecureFileName(filePath);
            List<CxProblems> scanDetails = entry.getValue();

            VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(filePath);
            Icon icon = virtualFile != null ? virtualFile.getFileType().getIcon() : null;
            PsiFile psiFile = PsiManager.getInstance(project).findFile(virtualFile);
            if (psiFile != null) {
                icon = psiFile.getIcon(Iconable.ICON_FLAG_VISIBILITY | Iconable.ICON_FLAG_READ_STATUS);
            }

            DefaultMutableTreeNode fileNode = new DefaultMutableTreeNode(
                    new FileNodeLabel(fileName, filePath, scanDetails.size(), icon)
            );

            for (CxProblems detail : scanDetails) {
                fileNode.add(new DefaultMutableTreeNode(new ScanDetailWithPath(detail, filePath)));
            }
            rootNode.add(fileNode);
        }
        ((DefaultTreeModel) tree.getModel()).reload();

        // Expand nodes by file path after reload
        SwingUtilities.invokeLater(() -> {
            for (int i = 0; i < tree.getRowCount(); i++) {
                TreePath path = tree.getPathForRow(i);
                if (path != null) {
                    Object lastNode = path.getLastPathComponent();
                    if (lastNode instanceof DefaultMutableTreeNode) {
                        DefaultMutableTreeNode node = (DefaultMutableTreeNode) lastNode;
                        Object userObject = node.getUserObject();
                        if (userObject instanceof FileNodeLabel &&
                                expandedPathsSet.contains(((FileNodeLabel) userObject).filePath)) {
                            tree.expandPath(path);
                        }
                    }
                }
            }
        });
    }

    private void navigateToSelectedIssue() {
        Object selected = tree.getLastSelectedPathComponent();
        if (!(selected instanceof DefaultMutableTreeNode)) return;
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) selected;
        Object userObj = node.getUserObject();
        if (!(userObj instanceof ScanDetailWithPath)) return;

        ScanDetailWithPath detailWithPath = (ScanDetailWithPath) userObj;
        CxProblems detail = detailWithPath.detail;
        String filePath = detailWithPath.filePath;
        int lineNumber = detail.getLine();

        VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(filePath);
        if (virtualFile == null) return;

        FileEditorManager editorManager = FileEditorManager.getInstance(project);
        editorManager.openFile(virtualFile, true);
        Editor editor = editorManager.getSelectedTextEditor();
        if (editor != null) {
            Document document = editor.getDocument();
            LogicalPosition logicalPosition = new LogicalPosition(lineNumber - 1, 0);
            editor.getCaretModel().moveToLogicalPosition(logicalPosition);
            editor.getScrollingModel().scrollTo(logicalPosition, ScrollType.CENTER);

        }
    }

    private void handleRightClick(MouseEvent e) {
        if (!e.isPopupTrigger()) return;
        int row = tree.getClosestRowForLocation(e.getX(), e.getY());
        tree.setSelectionRow(row);
        Object selected = tree.getLastSelectedPathComponent();
        if (!(selected instanceof DefaultMutableTreeNode)) return;
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) selected;
        Object userObj = node.getUserObject();
        if (!(userObj instanceof ScanDetailWithPath)) return;

        CxProblems detail = ((ScanDetailWithPath) userObj).detail;
        JPopupMenu popup = createPopupMenu(detail);
        popup.show(tree, e.getX(), e.getY());
    }

    private static class IssueTreeRenderer extends ColoredTreeCellRenderer {
        private int hoveredRow = -1;
        private final Icon bulbIcon = AllIcons.Actions.IntentionBulb;
        int currentRow = -1;

        public IssueTreeRenderer(JTree tree) {
            tree.addMouseMotionListener(new MouseMotionAdapter() {
                @Override
                public void mouseMoved(MouseEvent e) {
                    int row = tree.getRowForLocation(e.getX(), e.getY());
                    if (row != hoveredRow) {
                        hoveredRow = row;
                        tree.repaint(); // Repaint tree for icon update
                    }
                }
            });

            tree.addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    int row = tree.getRowForLocation(e.getX(), e.getY());
                    if (row == -1) {
                        tree.clearSelection();
                    }
                }
            });

        }

        @Override
        public void customizeCellRenderer(JTree tree, Object value, boolean selected,
                                          boolean expanded, boolean leaf, int row, boolean hasFocus) {
            currentRow = row;
            if (!(value instanceof DefaultMutableTreeNode)) return;

            DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
            Object obj = node.getUserObject();
            Icon icon = null;

            if (obj instanceof FileNodeLabel) {
                FileNodeLabel info = (FileNodeLabel) obj;
                if (info.icon != null) {
                    setIcon(info.icon);
                }
                append(info.fileName, SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);
                // + info.filePath + " " - use this if you want to show the full path
                append(" " + info.problemCount , SimpleTextAttributes.GRAYED_ATTRIBUTES);

            } else if (obj instanceof ScanDetailWithPath) {
                CxProblems detail = ((ScanDetailWithPath) obj).detail;
                String scannerType = detail.getScannerType();

                icon = severityToIcon.getOrDefault(detail.getSeverity(), null);
                if (icon != null) setIcon(icon);

                if ("ASCA".equalsIgnoreCase(scannerType)) {
                    append(detail.getTitle()+ " - " + detail.getRemediationAdvise(), SimpleTextAttributes.REGULAR_ATTRIBUTES);
                } else if ("OSS".equalsIgnoreCase(scannerType)) {
                    append(detail.getSeverity()+"-risk package: "+ detail.getTitle()+"@"+detail.getPackageVersion(), SimpleTextAttributes.REGULAR_ATTRIBUTES);
                } else {
                    append(detail.getDescription(), SimpleTextAttributes.REGULAR_ATTRIBUTES);
                }
                append(" " + Constants.CXONE_ASSIST+ " ", SimpleTextAttributes.GRAYED_ATTRIBUTES);

                int line = detail.getLine();
                Integer column = detail.getColumn();
                String lineColText = "[Ln " + line;
                if (column != null) {
                    lineColText += ", Col " + column;
                }
                lineColText += "]";
                append(lineColText, SimpleTextAttributes.GRAYED_ATTRIBUTES);

                if (hoveredRow == row) {
                    icon = bulbIcon; // show bulb on hover
                    setIcon(icon);
                }
            } else if (obj instanceof String) {
                setIcon(null);
                append((String) obj, SimpleTextAttributes.REGULAR_ATTRIBUTES);
            }
        }

        @Override
        protected void paintComponent(Graphics g) {
            if (hoveredRow == currentRow) {
                Graphics2D g2d = (Graphics2D) g.create();
                try {
                    // Paint a light strip spanning full width and row height
                    g2d.setColor(new Color(211, 211, 211, 40)); // translucent light gray
                    g2d.fillRect(0, 0, getWidth(), getHeight());
                } finally {
                    g2d.dispose();
                }
            }
            super.paintComponent(g);
        }
    }

    @Override
    public void dispose() {
        // Cleanup if needed
    }

    public static class ScanDetailWithPath {
        public final CxProblems detail;
        public final String filePath;

        public ScanDetailWithPath(CxProblems detail, String filePath) {
            this.detail = detail;
            this.filePath = filePath;
        }
    }

    private JPopupMenu createPopupMenu(CxProblems detail) {
        JPopupMenu popup = new JPopupMenu();

        JMenuItem promptOption = new JMenuItem("Fix with CxOne Assist");
        popup.add(promptOption);

        JMenuItem copyDescription = new JMenuItem("View Details");
        copyDescription.addActionListener(ev -> {
            String description = detail.getDescription();
            Toolkit.getDefaultToolkit().getSystemClipboard()
                    .setContents(new StringSelection(description), null);
        });
        popup.add(copyDescription);

        JMenuItem ignoreOption = new JMenuItem("Ignore this vulnerability");
        popup.add(ignoreOption);

        JMenuItem ignoreAllOption = new JMenuItem("Ignore all of this type");
        popup.add(ignoreAllOption);
        popup.add(new JSeparator());

        JMenuItem copyFix = new JMenuItem("Copy");
        copyFix.addActionListener(ev -> {
            try {
                ObjectMapper mapper = new ObjectMapper();
                String json = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(Collections.singletonList(detail));
                Toolkit.getDefaultToolkit().getSystemClipboard()
                        .setContents(new StringSelection(json), null);
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
        popup.add(copyFix);

        JMenuItem CopyMessage = new JMenuItem("Copy Message");
        CopyMessage.addActionListener(ev -> {
            String message = detail.getSeverity()+"-risk package: "+ detail.getTitle()+"@"+detail.getPackageVersion();
            Toolkit.getDefaultToolkit().getSystemClipboard()
                    .setContents(new StringSelection(message), null);
        });
        popup.add(CopyMessage);

        return popup;
    }

    private String getSecureFileName(String filePath) {
        if (filePath == null || filePath.trim().isEmpty()) {
            return "unknown";
        }
        try {
            Path path = Paths.get(filePath).normalize();
            Path fileName = path.getFileName();
            if (fileName != null) {
                return fileName.toString();
            }
            return path.toString();
        } catch (java.nio.file.InvalidPathException e) {
            return filePath.substring(Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\')) + 1);
        }
    }

    public static class FileNodeLabel {
        public final String fileName;
        public final String filePath;
        public final int problemCount;
        public final Icon icon;
        public FileNodeLabel(String fileName, String filePath, int problemCount, Icon icon) {
            this.fileName = fileName;
            this.filePath = filePath;
            this.problemCount = problemCount;
            this.icon = icon;
        }
    }

    public void updateTabTitle() {
        int count = getProblemCount();
        if (count > 0) {
            content.setDisplayName("<html> CxOne Problems <span style='color:gray'>" + count + "</span></html>");
        }

    }

    public int getProblemCount() {
        int count = 0;
        Enumeration children = rootNode.children();
        while (children.hasMoreElements()) {
            DefaultMutableTreeNode fileNode = (DefaultMutableTreeNode) children.nextElement();
            count += fileNode.getChildCount(); // problems under each file node
        }
        return count;
    }


}