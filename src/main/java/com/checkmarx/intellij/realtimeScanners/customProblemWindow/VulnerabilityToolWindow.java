package com.checkmarx.intellij.realtimeScanners.customProblemWindow;

import com.checkmarx.intellij.Constants;
import com.checkmarx.intellij.realtimeScanners.dto.CxProblems;
import com.checkmarx.intellij.service.ProblemHolderService;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.editor.*;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.SimpleToolWindowPanel;
import com.intellij.openapi.vfs.LocalFileSystem;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.ui.treeStructure.SimpleTree;
import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.List;
import com.intellij.ui.ColoredTreeCellRenderer;
import com.intellij.ui.SimpleTextAttributes;

public class VulnerabilityToolWindow extends SimpleToolWindowPanel implements Disposable {

    private final Project project;
    private final SimpleTree tree;
    private final DefaultMutableTreeNode rootNode;
    private static Map<String, Icon> severityToIcon;

    public VulnerabilityToolWindow(Project project) {
        super(true, true);
        this.project = project;
        this.tree = new SimpleTree();
        this.rootNode = new DefaultMutableTreeNode();
        tree.setModel(new javax.swing.tree.DefaultTreeModel(rootNode));
        tree.setCellRenderer(new IssueTreeRenderer());
        tree.setRootVisible(false);

        add(new JScrollPane(tree), BorderLayout.CENTER);
        initSeverityIcons();

        tree.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) navigateToSelectedIssue();
            }

            @Override
            public void mousePressed(MouseEvent e) {
                handleRightClick(e);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                handleRightClick(e);
            }
        });

        // Subscribe to updates
        project.getMessageBus().connect(this)
                .subscribe(ProblemHolderService.ISSUE_TOPIC, new ProblemHolderService.IssueListener() {
                    @Override
                    public void onIssuesUpdated(Map<String, List<CxProblems>> issues) {
                        SwingUtilities.invokeLater(() -> refreshTree(issues));
                    }
                });
    }

    private void initSeverityIcons() {
        severityToIcon = new HashMap<>();
        severityToIcon.put(Constants.ASCA_CRITICAL_SEVERITY, AllIcons.General.Error);
        severityToIcon.put(Constants.ASCA_HIGH_SEVERITY, AllIcons.General.Error);
        severityToIcon.put(Constants.ASCA_MEDIUM_SEVERITY, AllIcons.General.Warning);
        severityToIcon.put(Constants.ASCA_LOW_SEVERITY, AllIcons.General.Information);
    }

    public void refreshTree(Map<String, List<CxProblems>> issues) {
        // Save expanded file node names (file paths)
        Set<String> expandedPathsSet = new java.util.HashSet<>();

        int rowCount = tree.getRowCount();
        for (int i = 0; i < rowCount; i++) {
            TreePath path = tree.getPathForRow(i);
            if (path != null && tree.isExpanded(path)) {
                Object lastNode = path.getLastPathComponent();
                if (lastNode instanceof DefaultMutableTreeNode) {
                    DefaultMutableTreeNode node = (DefaultMutableTreeNode) lastNode;
                    Object userObject = node.getUserObject();
                    if (userObject instanceof FileNodeLabel) {  // file path nodes
                        expandedPathsSet.add(((FileNodeLabel) userObject).filePath);
                    }
                }
            }
        }
        // Clear and rebuild tree
        rootNode.removeAllChildren();
        for (Map.Entry<String, List<CxProblems>> entry : issues.entrySet()) {
            String filePath = entry.getKey();
            String fileName = getSecureFileName(filePath);
            List<CxProblems> scanDetails = entry.getValue();
            VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(filePath);
            Icon icon = virtualFile != null ? virtualFile.getFileType().getIcon() : null;

            DefaultMutableTreeNode fileNode = new DefaultMutableTreeNode(
                    new FileNodeLabel(fileName, filePath, scanDetails.size(), icon)
            );

            for (CxProblems detail : scanDetails) {
                fileNode.add(new DefaultMutableTreeNode(new ScanDetailWithPath(detail, filePath)));
            }
            rootNode.add(fileNode);
        }
        ((DefaultTreeModel) tree.getModel()).reload();

        // Expand nodes by file path after reload
        SwingUtilities.invokeLater(() -> {
            for (int i = 0; i < tree.getRowCount(); i++) {
                TreePath path = tree.getPathForRow(i);
                if (path != null) {
                    Object lastNode = path.getLastPathComponent();
                    if (lastNode instanceof DefaultMutableTreeNode) {
                        DefaultMutableTreeNode node = (DefaultMutableTreeNode) lastNode;
                        Object userObject = node.getUserObject();
                        if (userObject instanceof FileNodeLabel &&
                                expandedPathsSet.contains(((FileNodeLabel) userObject).filePath)) {
                            tree.expandPath(path);
                        }
                    }
                }
            }
        });
    }

    private void navigateToSelectedIssue() {
        Object selected = tree.getLastSelectedPathComponent();
        if (!(selected instanceof DefaultMutableTreeNode)) return;
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) selected;
        Object userObj = node.getUserObject();
        if (!(userObj instanceof ScanDetailWithPath)) return;

        ScanDetailWithPath detailWithPath = (ScanDetailWithPath) userObj;
        CxProblems detail = detailWithPath.detail;
        String filePath = detailWithPath.filePath;
        int lineNumber = detail.getLine();

        VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(filePath);
        if (virtualFile == null) return;

        FileEditorManager editorManager = FileEditorManager.getInstance(project);
        editorManager.openFile(virtualFile, true);
        Editor editor = editorManager.getSelectedTextEditor();
        if (editor != null) {
            Document document = editor.getDocument();
            LogicalPosition logicalPosition = new LogicalPosition(lineNumber - 1, 0);
            editor.getCaretModel().moveToLogicalPosition(logicalPosition);
            editor.getScrollingModel().scrollTo(logicalPosition, ScrollType.CENTER);

        }
    }

    private void handleRightClick(MouseEvent e) {
        if (!e.isPopupTrigger()) return;
        int row = tree.getClosestRowForLocation(e.getX(), e.getY());
        tree.setSelectionRow(row);
        Object selected = tree.getLastSelectedPathComponent();
        if (!(selected instanceof DefaultMutableTreeNode)) return;
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) selected;
        Object userObj = node.getUserObject();
        if (!(userObj instanceof ScanDetailWithPath)) return;

        CxProblems detail = ((ScanDetailWithPath) userObj).detail;
        JPopupMenu popup = createPopupMenu(detail);
        popup.show(tree, e.getX(), e.getY());
    }

    private static class IssueTreeRenderer extends ColoredTreeCellRenderer {
        @Override
        public void customizeCellRenderer(JTree tree, Object value, boolean selected,
                                          boolean expanded, boolean leaf, int row, boolean hasFocus) {
            if (!(value instanceof DefaultMutableTreeNode)) return;

            DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
            Object obj = node.getUserObject();

            if (obj instanceof FileNodeLabel) {
                FileNodeLabel info = (FileNodeLabel) obj;
                if (info.icon != null) {
                    setIcon(info.icon);
                }
                append(info.fileName, SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);
                append(" " + info.filePath + " " + info.problemCount + " problems", SimpleTextAttributes.GRAYED_ATTRIBUTES);

            } else if (obj instanceof ScanDetailWithPath) {
                CxProblems detail = ((ScanDetailWithPath) obj).detail;
                String scannerType = detail.getScannerType();

                Icon icon = severityToIcon.getOrDefault(detail.getSeverity(), null);
                if (icon != null) setIcon(icon);

                if ("ASCA".equalsIgnoreCase(scannerType)) {
                    append(detail.getRuleName()+ " - " + detail.getRemediationAdvise(), SimpleTextAttributes.REGULAR_ATTRIBUTES);
                } else if ("OSS".equalsIgnoreCase(scannerType)) {
                    append(detail.getCve(), SimpleTextAttributes.REGULAR_ATTRIBUTES);
                    append(detail.getPackageVersion(), SimpleTextAttributes.REGULAR_ATTRIBUTES);
                } else {
                    append(detail.getDescription(), SimpleTextAttributes.REGULAR_ATTRIBUTES);
                }
                append(" (line " + detail.getLine() + ")", SimpleTextAttributes.GRAYED_ATTRIBUTES);

            } else if (obj instanceof String) {
                setIcon(null);
                append((String) obj, SimpleTextAttributes.REGULAR_ATTRIBUTES);
            }
        }
    }


    @Override
    public void dispose() {
        // Cleanup if needed
    }

    public static class ScanDetailWithPath {
        public final CxProblems detail;
        public final String filePath;

        public ScanDetailWithPath(CxProblems detail, String filePath) {
            this.detail = detail;
            this.filePath = filePath;
        }
    }

    private JPopupMenu createPopupMenu(CxProblems detail) {
        JPopupMenu popup = new JPopupMenu();

        JMenuItem promptOption = new JMenuItem("Fix with CxOne Assist");
        promptOption.setEnabled(false); // Placeholder, disabled for now
        popup.add(promptOption);

        JMenuItem copyDescription = new JMenuItem("View Details");
        copyDescription.addActionListener(ev -> {
            String description = detail.getDescription();
            Toolkit.getDefaultToolkit().getSystemClipboard()
                    .setContents(new StringSelection(description), null);
        });
        popup.add(copyDescription);

        JMenuItem copyFix = new JMenuItem("Copy Fix");
        copyFix.addActionListener(ev -> {
            String fixText = detail.getRemediationAdvise();
            Toolkit.getDefaultToolkit().getSystemClipboard()
                    .setContents(new StringSelection(fixText), null);
        });
        popup.add(copyFix);

        JMenuItem ignoreOption = new JMenuItem("Ignore this vulnerability");
        promptOption.setEnabled(false); // Placeholder, disabled for now
        popup.add(promptOption);


        return popup;
    }

    private String getSecureFileName(String filePath) {
        if (filePath == null || filePath.trim().isEmpty()) {
            return "unknown";
        }
        try {
            Path path = Paths.get(filePath).normalize();
            Path fileName = path.getFileName();
            if (fileName != null) {
                return fileName.toString();
            }
            return path.toString();
        } catch (java.nio.file.InvalidPathException e) {
            return filePath.substring(Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\')) + 1);
        }
    }

    public static class FileNodeLabel {
        public final String fileName;
        public final String filePath;
        public final int problemCount;
        public final Icon icon;
        public FileNodeLabel(String fileName, String filePath, int problemCount, Icon icon) {
            this.fileName = fileName;
            this.filePath = filePath;
            this.problemCount = problemCount;
            this.icon = icon;
        }
    }

    public int getProblemCount() {
        int count = 0;
        Enumeration children = rootNode.children();
        while (children.hasMoreElements()) {
            DefaultMutableTreeNode fileNode = (DefaultMutableTreeNode) children.nextElement();
            count += fileNode.getChildCount(); // problems under each file node
        }
        return count;
    }


}