package com.checkmarx.intellij.tool.window;

import com.checkmarx.ast.asca.ScanDetail;
import com.checkmarx.intellij.Constants;
import com.checkmarx.intellij.service.AscaVulnerabilityService;
import com.intellij.codeInspection.ProblemHighlightType;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.editor.*;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.SimpleToolWindowPanel;
import com.intellij.openapi.vfs.LocalFileSystem;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.ui.treeStructure.SimpleNode;
import com.intellij.ui.treeStructure.SimpleTree;
import com.intellij.ui.treeStructure.SimpleTreeBuilder;
import com.intellij.ui.treeStructure.SimpleTreeStructure;
import javax.swing.*;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeCellRenderer;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AscaVulnerabilityToolWindow extends SimpleToolWindowPanel implements Disposable {

    private final Project project;
    private final SimpleTree tree;
    private final SimpleTreeBuilder treeBuilder; // keep a single builder
    private final RootNode root;
    public static String ASCA_INSPECTION_ID = "ASCA";
    private static Map<String, ProblemHighlightType> severityToHighlightMap;

    public AscaVulnerabilityToolWindow(Project project) {
        super(true, true);
        this.project = project;

        this.tree = new SimpleTree();

        tree.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) { // Handle double-click
                    navigateToIssue();
                }
            }
        });


        setContent(new JScrollPane(tree));

        // Apply custom renderer for severity-based styling
        tree.setCellRenderer((TreeCellRenderer) new IssueTreeRenderer());

        // Initialize root and builder once
        root = new RootNode(AscaVulnerabilityService.getInstance(project).getAllIssues());

        SimpleTreeStructure structure = new SimpleTreeStructure() {
            @Override
            public Object getRootElement() {
                return root;
            }
        };

        treeBuilder = new SimpleTreeBuilder(tree, (DefaultTreeModel) tree.getModel(), structure, null);
        treeBuilder.initRoot();

        // Subscribe to updates
        project.getMessageBus().connect(this)
                .subscribe(AscaVulnerabilityService.ISSUE_TOPIC, new AscaVulnerabilityService.IssueListener() {
                    @Override
                    public void onIssuesUpdated(Map<String, List<ScanDetail>> issues) {
                        SwingUtilities.invokeLater(() -> refreshTree());
                    }
                });
    }

    public void refreshTree() {
        Map<String, List<ScanDetail>> issues = AscaVulnerabilityService.getInstance(project).getAllIssues();
        root.setIssues(issues);
        treeBuilder.queueUpdate(true); // refresh UI
    }

    @Override
    public void dispose() {
    }


    private static class RootNode extends SimpleNode {
        private Map<String, List<ScanDetail>> issues;

        RootNode(Map<String, List<ScanDetail>> issues) {
            this.issues = issues;
        }

        void setIssues(Map<String, List<ScanDetail>> issues) {
            this.issues = issues;
        }

        @Override
        public SimpleNode[] getChildren() {
            return issues.entrySet().stream()
                    .map(entry -> new FileNode(this, entry.getKey(), entry.getValue()))
                    .toArray(SimpleNode[]::new);
        }

        @Override
        public String getName() {
            return "ASCA Issues";
        }
    }

    private static class FileNode extends SimpleNode {
        private final String filePath;
        private final List<ScanDetail> issues;

        FileNode(SimpleNode parent, String filePath, List<ScanDetail> issues) {
            super(parent);
            this.filePath = filePath;
            this.issues = issues;
        }

        @Override
        public SimpleNode[] getChildren() {
            return issues.stream()
                    .map(issue -> new IssueNode(this, issue, filePath))
                    .toArray(SimpleNode[]::new);
        }

        @Override
        public String getName() {
            return filePath;
        }
    }

    private static class IssueNode extends SimpleNode {
        private final ScanDetail detail;
        private final String filePath;

        IssueNode(SimpleNode parent, ScanDetail detail, String filePath) {
            super(parent);
            this.filePath = filePath;
            this.detail = detail;
        }

        @Override
        public SimpleNode[] getChildren() {
            return NO_CHILDREN;
        }

        @Override
        public String getName() {
            // keep raw name for debugging, renderer will show formatted
            return detail.getRuleName() + " at line " + detail.getLine();
        }

        public ScanDetail getDetail() {
            return detail;
        }

        public String getFilePath() { // New method
            return filePath;
        }
    }

    private static class IssueTreeRenderer extends DefaultTreeCellRenderer {

        @Override
        public Component getTreeCellRendererComponent(
                JTree tree, Object value, boolean sel, boolean expanded,
                boolean leaf, int row, boolean hasFocus) {

            JLabel label = (JLabel) super.getTreeCellRendererComponent(
                    tree, value, sel, expanded, leaf, row, hasFocus);

            if (value instanceof IssueNode) {
                IssueNode issueNode = (IssueNode) value;
                ScanDetail detail = issueNode.getDetail();

                // Get the highlight type from your detail or a helper method
                ProblemHighlightType highlightType = determineHighlightType(detail);

                // Map the highlight type to the correct icon
                Icon icon;
                if (highlightType == ProblemHighlightType.GENERIC_ERROR || highlightType == ProblemHighlightType.ERROR) {
                    icon = AllIcons.General.Error;
                } else if (highlightType == ProblemHighlightType.WARNING) {
                    icon = AllIcons.General.Warning;
                } else if (highlightType == ProblemHighlightType.WEAK_WARNING) {
                    icon = AllIcons.General.Information; // Or a similar low-priority icon
                } else {
                    icon = null;
                }
                label.setIcon(icon);
            }
            return label;
        }
    }

        /**
         * Determines the highlight type for a specific scan detail.
         *
         * @param detail the scan detail
         * @return the problem highlight type
         */
        private static ProblemHighlightType determineHighlightType(ScanDetail detail) {
            return getSeverityToHighlightMap().getOrDefault(detail.getSeverity(), ProblemHighlightType.WEAK_WARNING);
        }

        /**
         * Gets the map of severity to highlight type.
         *
         * @return the map of severity to highlight type
         */
        private static Map<String, ProblemHighlightType> getSeverityToHighlightMap() {
            if (severityToHighlightMap == null) {
                severityToHighlightMap = new HashMap<>();
                severityToHighlightMap.put(Constants.ASCA_CRITICAL_SEVERITY, ProblemHighlightType.GENERIC_ERROR);
                severityToHighlightMap.put(Constants.ASCA_HIGH_SEVERITY, ProblemHighlightType.GENERIC_ERROR);
                severityToHighlightMap.put(Constants.ASCA_MEDIUM_SEVERITY, ProblemHighlightType.WARNING);
                severityToHighlightMap.put(Constants.ASCA_LOW_SEVERITY, ProblemHighlightType.WEAK_WARNING);
            }
            return severityToHighlightMap;
        }


    private void navigateToIssue() {
        SimpleNode selectedNode = (SimpleNode) tree.getSelectedNode();
        if (selectedNode instanceof IssueNode) {
            IssueNode issueNode = (IssueNode) selectedNode;
            ScanDetail detail = issueNode.getDetail();

            String filePath = issueNode.getFilePath();
            int lineNumber = detail.getLine();

            VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(filePath);
            if (virtualFile == null) {
                return;
            }

            FileEditorManager editorManager = FileEditorManager.getInstance(project);
            editorManager.openFile(virtualFile, true);
            Editor editor = editorManager.getSelectedTextEditor();
            if (editor != null) {
                Document document = editor.getDocument();
                // Get the LogicalPosition for the start of the line
                LogicalPosition logicalPosition = new LogicalPosition(lineNumber - 1, 0);

                // Move the caret to the start of the line
                editor.getCaretModel().moveToLogicalPosition(logicalPosition);

                // Scroll the view to bring the line into view.
                editor.getScrollingModel().scrollTo(logicalPosition, ScrollType.CENTER);
            }
        }
    }
}