package com.checkmarx.intellij.devassist.ui;

import com.checkmarx.intellij.Constants;
import com.checkmarx.intellij.CxIcons;
import com.checkmarx.intellij.Utils;
import com.checkmarx.intellij.devassist.model.Location;
import com.checkmarx.intellij.devassist.model.ScanIssue;
import com.checkmarx.intellij.devassist.problems.ProblemHolderService;
import com.checkmarx.intellij.devassist.ui.filterAction.VulnerabilityFilterBaseAction;
import com.checkmarx.intellij.devassist.ui.filterAction.VulnerabilityFilterState;
import com.checkmarx.intellij.tool.window.actions.filter.Filterable;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.actionSystem.*;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.editor.LogicalPosition;
import com.intellij.openapi.editor.ScrollType;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.SimpleToolWindowPanel;
import com.intellij.openapi.util.Disposer;
import com.intellij.openapi.util.Iconable;
import com.intellij.openapi.vfs.LocalFileSystem;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiManager;
import com.intellij.ui.ColoredTreeCellRenderer;
import com.intellij.ui.SimpleTextAttributes;
import com.intellij.ui.content.Content;
import com.intellij.ui.treeStructure.SimpleTree;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.Timer;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

public class VulnerabilityToolWindow extends SimpleToolWindowPanel
        implements Disposable, VulnerabilityToolWindowAction {

    private static final Logger LOGGER = Utils.getLogger(VulnerabilityToolWindow.class);
    private final Project project;
    private final SimpleTree tree;
    private final DefaultMutableTreeNode rootNode;
    private static Map<String, Icon> severityToIcon;
    private static Set<String> expandedPathsSet = new java.util.HashSet<>();
    private final Content content;
    private final Timer timer;

    public VulnerabilityToolWindow(Project project, Content content) {
        super(false, true);
        this.project = project;
        this.tree = new SimpleTree();
        this.rootNode = new DefaultMutableTreeNode();
        this.content = content;

        // Setup toolbar
        ActionToolbar toolbar = createActionToolbar();
        toolbar.setTargetComponent(this);
        setToolbar(toolbar.getComponent());

        // Subscribe to filter changes using FilterBaseAction's topic to refresh tree on
        // toggle
        project.getMessageBus().connect(this)
                .subscribe(VulnerabilityFilterBaseAction.TOPIC,
                        new VulnerabilityFilterBaseAction.VulnerabilityFilterChanged() {
                            @Override
                            public void filterChanged() {
                                ApplicationManager.getApplication().invokeLater(() -> triggerRefreshTree());
                            }
                        });

        LOGGER.info("Initiated the custom problem window for project: " + project.getName());
        add(new JScrollPane(tree), BorderLayout.CENTER);
        initSeverityIcons();

        tree.setModel(new javax.swing.tree.DefaultTreeModel(rootNode));
        tree.setCellRenderer(new IssueTreeRenderer(tree));
        tree.setRootVisible(false);
        tree.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 1)
                    navigateToSelectedIssue();
            }

            @Override
            public void mousePressed(MouseEvent e) {
                handleRightClick(e);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                handleRightClick(e);
            }
        });

        timer = new Timer(1000, e -> updateTabTitle());
        timer.start();

        // Ensure proper disposal of timer
        Disposer.register(this, () -> timer.stop());

        project.getMessageBus().connect(this)
                .subscribe(ProblemHolderService.ISSUE_TOPIC, new ProblemHolderService.IssueListener() {
                    @Override
                    public void onIssuesUpdated(Map<String, List<ScanIssue>> issues) {
                        ApplicationManager.getApplication().invokeLater(() -> triggerRefreshTree());
                    }
                });

    }

    private void initSeverityIcons() {
        severityToIcon = new HashMap<>();
        severityToIcon.put(Constants.MALICIOUS_SEVERITY, CxIcons.getMaliciousIcon());
        severityToIcon.put(Constants.CRITICAL_SEVERITY, CxIcons.getCriticalIcon());
        severityToIcon.put(Constants.HIGH_SEVERITY, CxIcons.getHighIcon());
        severityToIcon.put(Constants.MEDIUM_SEVERITY, CxIcons.getMediumIcon());
        severityToIcon.put(Constants.LOW_SEVERITY, CxIcons.getLowIcon());
    }

    /**
     * Retrieve issues, apply filtering, and refresh the UI tree.
     */
    private void triggerRefreshTree() {
        Map<String, List<ScanIssue>> allIssues = ProblemHolderService.getInstance(project).getAllIssues();
        if (allIssues == null)
            return;

        Set<Filterable> activeFilters = VulnerabilityFilterState.getInstance().getFilters();

        Map<String, List<ScanIssue>> filteredIssues = new HashMap<>();

        for (Map.Entry<String, List<ScanIssue>> entry : allIssues.entrySet()) {
            List<ScanIssue> filteredList = entry.getValue().stream()
                    .filter(issue -> activeFilters.stream()
                            .anyMatch(f -> f.getFilterValue().equalsIgnoreCase(issue.getSeverity())))
                    .collect(Collectors.toList());

            if (!filteredList.isEmpty()) {
                filteredIssues.put(entry.getKey(), filteredList);
            }
        }
        refreshTree(filteredIssues);
    }

    public void refreshTree(Map<String, List<ScanIssue>> issues) {
        int rowCount = tree.getRowCount();
        for (int i = 0; i < rowCount; i++) {
            TreePath path = tree.getPathForRow(i);
            if (path != null && tree.isExpanded(path)) {
                Object lastNode = path.getLastPathComponent();
                if (lastNode instanceof DefaultMutableTreeNode) {
                    DefaultMutableTreeNode node = (DefaultMutableTreeNode) lastNode;
                    Object userObject = node.getUserObject();
                    if (userObject instanceof FileNodeLabel) { // file path nodes
                        expandedPathsSet.add(((FileNodeLabel) userObject).filePath);
                    }
                }
            }
        }
        // Clear and rebuild tree
        rootNode.removeAllChildren();
        for (Map.Entry<String, List<ScanIssue>> entry : issues.entrySet()) {
            String filePath = entry.getKey();
            String fileName = getSecureFileName(filePath);
            List<ScanIssue> scanDetails = entry.getValue();

            // Filtered problems (excluding "ok" and "unknown")
            List<ScanIssue> filteredScanDetails = scanDetails.stream()
                    .filter(detail -> {
                        String severity = detail.getSeverity();
                        return !"ok".equalsIgnoreCase(severity) && !"unknown".equalsIgnoreCase(severity);
                    })
                    .collect(Collectors.toList());

            VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(filePath);
            Icon icon = virtualFile != null ? virtualFile.getFileType().getIcon() : null;
            PsiFile psiFile = PsiManager.getInstance(project).findFile(virtualFile);
            if (psiFile != null) {
                icon = psiFile.getIcon(Iconable.ICON_FLAG_VISIBILITY | Iconable.ICON_FLAG_READ_STATUS);
            }

            // Count issues by severity
            Map<String, Long> severityCounts = filteredScanDetails.stream()
                    .collect(Collectors.groupingBy(ScanIssue::getSeverity, Collectors.counting()));
            DefaultMutableTreeNode fileNode = new DefaultMutableTreeNode(
                    new FileNodeLabel(fileName, filePath, severityCounts, icon));

            for (ScanIssue detail : filteredScanDetails) {
                fileNode.add(new DefaultMutableTreeNode(new ScanDetailWithPath(detail, filePath)));
            }

            rootNode.add(fileNode);
        }
        ((DefaultTreeModel) tree.getModel()).reload();

        expandNodesByFilePath();
    }

    /**
     * Expand nodes by file path after reload
     */
    private void expandNodesByFilePath() {
        SwingUtilities.invokeLater(() -> {
            for (int i = 0; i < tree.getRowCount(); i++) {
                TreePath path = tree.getPathForRow(i);
                if (path != null) {
                    Object lastNode = path.getLastPathComponent();
                    if (lastNode instanceof DefaultMutableTreeNode) {
                        DefaultMutableTreeNode node = (DefaultMutableTreeNode) lastNode;
                        Object userObject = node.getUserObject();
                        if (userObject instanceof FileNodeLabel &&
                                expandedPathsSet.contains(((FileNodeLabel) userObject).filePath)) {
                            tree.expandPath(path);
                        }
                    }
                }
            }
        });
    }

    private void navigateToSelectedIssue() {
        Object selected = tree.getLastSelectedPathComponent();
        if (!(selected instanceof DefaultMutableTreeNode))
            return;
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) selected;
        Object userObj = node.getUserObject();
        if (!(userObj instanceof ScanDetailWithPath))
            return;

        ScanDetailWithPath detailWithPath = (ScanDetailWithPath) userObj;
        ScanIssue detail = detailWithPath.detail;
        String filePath = detailWithPath.filePath;

        if (detail.getLocations() != null && !detail.getLocations().isEmpty()) {
            // By default, navigate to the first occurrence
            Location targetLoc = detail.getLocations().get(0);

            int lineNumber = targetLoc.getLine();

            VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(filePath);
            if (virtualFile == null)
                return;

            FileEditorManager editorManager = FileEditorManager.getInstance(project);
            editorManager.openFile(virtualFile, true);
            Editor editor = editorManager.getSelectedTextEditor();
            if (editor != null) {
                Document document = editor.getDocument();
                LogicalPosition logicalPosition = new LogicalPosition(lineNumber - 1, 0);
                editor.getCaretModel().moveToLogicalPosition(logicalPosition);
                editor.getScrollingModel().scrollTo(logicalPosition, ScrollType.CENTER);

            }
        }
    }

    private void handleRightClick(MouseEvent e) {
        if (!e.isPopupTrigger())
            return;
        int row = tree.getClosestRowForLocation(e.getX(), e.getY());
        tree.setSelectionRow(row);
        Object selected = tree.getLastSelectedPathComponent();
        if (!(selected instanceof DefaultMutableTreeNode))
            return;
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) selected;
        Object userObj = node.getUserObject();
        if (!(userObj instanceof ScanDetailWithPath))
            return;

        ScanIssue detail = ((ScanDetailWithPath) userObj).detail;
        JPopupMenu popup = createPopupMenu(detail);
        popup.show(tree, e.getX(), e.getY());
    }

    private static class IssueTreeRenderer extends ColoredTreeCellRenderer {
        private int hoveredRow = -1;
        private final Icon bulbIcon = AllIcons.Actions.IntentionBulb;
        int currentRow = -1;
        private List<IconWithCount> severityIconsToDraw = new ArrayList<>();
        private String fileNameText = "";

        public IssueTreeRenderer(JTree tree) {
            tree.addMouseMotionListener(new MouseMotionAdapter() {
                @Override
                public void mouseMoved(MouseEvent e) {
                    int row = tree.getRowForLocation(e.getX(), e.getY());
                    if (row != hoveredRow) {
                        hoveredRow = row;
                        tree.repaint();
                    }
                }
            });

            tree.addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    int row = tree.getRowForLocation(e.getX(), e.getY());
                    if (row == -1) {
                        tree.clearSelection();
                    }
                }
            });
        }

        @Override
        public void customizeCellRenderer(JTree tree, Object value, boolean selected,
                                          boolean expanded, boolean leaf, int row, boolean hasFocus) {
            currentRow = row;
            severityIconsToDraw.clear();
            fileNameText = "";

            if (!(value instanceof DefaultMutableTreeNode))
                return;

            DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
            Object obj = node.getUserObject();
            Icon icon = null;
            LOGGER.info("Rendering the result tree");
            if (obj instanceof FileNodeLabel) {
                FileNodeLabel info = (FileNodeLabel) obj;
                if (info.icon != null) {
                    setIcon(info.icon);
                }
                fileNameText = info.fileName;
                append(info.fileName, SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);
                if (info.problemCount != null && !info.problemCount.isEmpty()) {
                    append("  ", SimpleTextAttributes.GRAY_ATTRIBUTES);
                    // Store icons and counts only, don't append counts as text here
                    for (Map.Entry<String, Long> entry : info.problemCount.entrySet()) {
                        Long count = entry.getValue();
                        if (count != null && count > 0) {
                            Icon severityIcon = severityToIcon.get(entry.getKey());
                            if (severityIcon != null) {
                                severityIconsToDraw.add(new IconWithCount(severityIcon, count));
                            }
                        }
                    }
                }
            } else if (obj instanceof ScanDetailWithPath) {
                ScanIssue detail = ((ScanDetailWithPath) obj).detail;

                icon = severityToIcon.getOrDefault(detail.getSeverity(), null);
                if (icon != null)
                    setIcon(icon);

                switch (detail.getScanEngine()) {
                    case ASCA:
                        append(detail.getTitle() + " ", SimpleTextAttributes.REGULAR_ATTRIBUTES);
                        break;
                    case OSS:
                        append(detail.getSeverity() + "-risk package: " + detail.getTitle() + "@"
                                + detail.getPackageVersion(), SimpleTextAttributes.REGULAR_ATTRIBUTES);
                        break;
                    default:
                        append(detail.getDescription(), SimpleTextAttributes.REGULAR_ATTRIBUTES);
                        break;
                }
                append(" " + Constants.CXONE_ASSIST + " ", SimpleTextAttributes.GRAYED_ATTRIBUTES);

                if (detail.getLocations() != null && !detail.getLocations().isEmpty()) {
                    // By default, navigate to the first occurrence
                    Location targetLoc = detail.getLocations().get(0);
                    int line = targetLoc.getLine();
                    Integer column = Math.max(0, targetLoc.getStartIndex());
                    String lineColText = "[Ln " + line;
                    if (column != null) {
                        lineColText += ", Col " + column;
                    }
                    lineColText += "]";
                    append(lineColText, SimpleTextAttributes.GRAYED_ATTRIBUTES);
                }
                if (hoveredRow == row) {
                    icon = bulbIcon; // show bulb on hover
                    setIcon(icon);
                }
            } else if (obj instanceof String) {
                setIcon(null);
                append((String) obj, SimpleTextAttributes.REGULAR_ATTRIBUTES);
            }
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);

            if (hoveredRow == currentRow) {
                Graphics2D g2d = (Graphics2D) g.create();
                try {
                    g2d.setColor(new Color(211, 211, 211, 40));
                    g2d.fillRect(0, 0, getWidth(), getHeight());
                } finally {
                    g2d.dispose();
                }
            }
            if (!severityIconsToDraw.isEmpty() && !fileNameText.isEmpty()) {
                Graphics2D g2 = (Graphics2D) g.create();
                try {
                    FontMetrics fm = getFontMetrics(getFont());

                    int x = getIpad().left;
                    if (getIcon() != null) {
                        x += getIcon().getIconWidth() + getIconTextGap();
                    }
                    x += fm.stringWidth("__");
                    x += fm.stringWidth(fileNameText);
                    x += fm.stringWidth("  ");

                    int y = (getHeight() - 16) / 2; // center vertically assuming 16px icons

                    int iconCountSpacing = 5; // space after count before next icon
                    int iconNumberSpacing = 1; // space between icon and count

                    for (IconWithCount iconWithCount : severityIconsToDraw) {
                        // Draw the icon
                        iconWithCount.icon.paintIcon(this, g2, x, y);

                        // Advance x by icon width + spacing
                        x += iconWithCount.icon.getIconWidth() + iconNumberSpacing;

                        String countStr = iconWithCount.count.toString();

                        // Compute width of count string
                        int countWidth = fm.stringWidth(countStr);

                        // Vertically center count text relative to icon
                        int countY = y + (iconWithCount.icon.getIconHeight() + fm.getAscent()) / 2 - 2;

                        // Draw count
                        g2.setColor(SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES.getFgColor());

                        Font baseFont = getFont();
                        Font boldFont = baseFont.deriveFont(Font.BOLD);
                        g2.setFont(boldFont);
                        g2.drawString(countStr, x, countY);

                        // Advance x by count width + spacing for next icon
                        x += countWidth + iconCountSpacing;
                    }

                } finally {
                    g2.dispose();
                }
            }
        }

        private static class IconWithCount {
            final Icon icon;
            final Long count;

            IconWithCount(Icon icon, Long count) {
                this.icon = icon;
                this.count = count;
            }
        }
    }

    @Override
    public void dispose() {
        // Cleanup if needed
    }

    public static class ScanDetailWithPath {
        public final ScanIssue detail;
        public final String filePath;

        public ScanDetailWithPath(ScanIssue detail, String filePath) {
            this.detail = detail;
            this.filePath = filePath;
        }
    }

    private JPopupMenu createPopupMenu(ScanIssue detail) {
        JPopupMenu popup = new JPopupMenu();

        JMenuItem promptOption = new JMenuItem("Fix with CxOne Assist");
        popup.add(promptOption);

        JMenuItem copyDescription = new JMenuItem("View Details");
        copyDescription.addActionListener(ev -> {
            String description = detail.getDescription();
            Toolkit.getDefaultToolkit().getSystemClipboard()
                    .setContents(new StringSelection(description), null);
        });
        popup.add(copyDescription);

        JMenuItem ignoreOption = new JMenuItem("Ignore this vulnerability");
        popup.add(ignoreOption);

        JMenuItem ignoreAllOption = new JMenuItem("Ignore all of this type");
        popup.add(ignoreAllOption);
        popup.add(new JSeparator());

        JMenuItem copyFix = new JMenuItem("Copy");
        copyFix.addActionListener(ev -> {
            try {
                ObjectMapper mapper = new ObjectMapper();
                String json = mapper.writerWithDefaultPrettyPrinter()
                        .writeValueAsString(Collections.singletonList(detail));
                Toolkit.getDefaultToolkit().getSystemClipboard()
                        .setContents(new StringSelection(json), null);
            } catch (Exception e) {
                LOGGER.warn("Failed to copy fix details", e);
            }
        });
        popup.add(copyFix);

        JMenuItem CopyMessage = new JMenuItem("Copy Message");
        CopyMessage.addActionListener(ev -> {
            String message = detail.getSeverity() + "-risk package: " + detail.getTitle() + "@"
                    + detail.getPackageVersion();
            Toolkit.getDefaultToolkit().getSystemClipboard()
                    .setContents(new StringSelection(message), null);
        });
        popup.add(CopyMessage);
        return popup;
    }

    private String getSecureFileName(String filePath) {
        if (filePath == null || filePath.trim().isEmpty()) {
            return "unknown";
        }
        try {
            Path path = Paths.get(filePath).normalize();
            Path fileName = path.getFileName();
            if (fileName != null) {
                return fileName.toString();
            }
            return path.toString();
        } catch (java.nio.file.InvalidPathException e) {
            return filePath.substring(Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\')) + 1);
        }
    }

    public static class FileNodeLabel {
        public final String fileName;
        public final String filePath;
        public final Map<String, Long> problemCount;
        public final Icon icon;

        public FileNodeLabel(String fileName, String filePath, Map<String, Long> problemCount, Icon icon) {
            this.fileName = fileName;
            this.filePath = filePath;
            this.problemCount = problemCount;
            this.icon = icon;
        }
    }

    public void updateTabTitle() {
        int count = getProblemCount();
        if (count > 0) {
            content.setDisplayName("<html> CxOne Assist Findings <span style='color:gray'>" + count + "</span></html>");
        }

    }

    public int getProblemCount() {
        int count = 0;
        Enumeration children = rootNode.children();
        while (children.hasMoreElements()) {
            DefaultMutableTreeNode fileNode = (DefaultMutableTreeNode) children.nextElement();
            count += fileNode.getChildCount(); // problems under each file node
        }
        return count;
    }

    @NotNull
    private ActionToolbar createActionToolbar() {
        ActionGroup group = (ActionGroup) ActionManager.getInstance().getAction("VulnerabilityToolbarGroup");

        if (group instanceof DefaultActionGroup) {
            DefaultActionGroup defaultGroup = (DefaultActionGroup) group;

            // Fetch individual actions
            AnAction expandAll = ActionManager.getInstance().getAction("Checkmarx.ExpandAll");
            AnAction collapseAll = ActionManager.getInstance().getAction("Checkmarx.CollapseAll");

            // Add actions at desired positions
            defaultGroup.add(expandAll, Constraints.LAST); // Adds at the start
            defaultGroup.add(collapseAll, Constraints.LAST); // Adds before expandAll (reversed order)
        }

        ActionToolbar toolbar = ActionManager.getInstance()
                .createActionToolbar(Constants.TOOL_WINDOW_ID, group, false);
        toolbar.setTargetComponent(this);
        return toolbar;
    }
}