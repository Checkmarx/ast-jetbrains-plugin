package com.checkmarx.intellij.unit.devassist.remediation;

import com.checkmarx.intellij.Constants;
import com.checkmarx.intellij.CxIcons;
import com.checkmarx.intellij.devassist.model.ScanIssue;
import com.checkmarx.intellij.devassist.remediation.IgnoreVulnerabilityFix;
import com.intellij.codeInspection.ProblemDescriptor;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Iconable;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import javax.swing.*;
import java.lang.reflect.Field;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class IgnoreVulnerabilityFixTest {

    private Project project;
    private ProblemDescriptor descriptor;
    private ScanIssue issue;

    @BeforeEach
    void setUp(){
        project = mock(Project.class, RETURNS_DEEP_STUBS);
        descriptor = mock(ProblemDescriptor.class);
        issue = new ScanIssue();
        issue.setTitle("Vuln Title");
    }

    @Test
    @DisplayName("Constructor creates instance with non-null ScanIssue")
    void testConstructor_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        assertNotNull(fix);
    }

    @Test
    @DisplayName("Constructor stores scanIssue field (reflection identity)")
    void testConstructor_storesScanIssue_functionality() throws Exception {
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        Field f = IgnoreVulnerabilityFix.class.getDeclaredField("scanIssue");
        f.setAccessible(true);
        assertSame(issue, f.get(fix));
    }

    @Test
    @DisplayName("getFamilyName returns expected constant")
    void testGetFamilyName_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        assertEquals(Constants.RealTimeConstants.IGNORE_THIS_VULNERABILITY_FIX_NAME, fix.getFamilyName());
    }

    @Test
    @DisplayName("getIcon returns STAR_ACTION for visibility flag")
    void testGetIcon_visibilityFlag_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        Icon icon = fix.getIcon(Iconable.ICON_FLAG_VISIBILITY);
        assertNotNull(icon); assertEquals(CxIcons.STAR_ACTION, icon);
    }

    @Test
    @DisplayName("getIcon returns STAR_ACTION for combined flags")
    void testGetIcon_combinedFlags_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        int flags = Iconable.ICON_FLAG_READ_STATUS | Iconable.ICON_FLAG_VISIBILITY;
        Icon icon = fix.getIcon(flags);
        assertNotNull(icon); assertEquals(CxIcons.STAR_ACTION, icon);
    }

    @Test
    @DisplayName("applyFix logs info without throwing when title present")
    void testApplyFix_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        assertDoesNotThrow(() -> fix.applyFix(project, descriptor));
    }

    @Test
    @DisplayName("applyFix handles null title gracefully")
    void testApplyFix_nullTitle_functionality(){
        issue.setTitle(null);
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        assertDoesNotThrow(() -> fix.applyFix(project, descriptor));
    }

    @Test
    @DisplayName("applyFix throws NullPointerException when scanIssue is null")
    void testApplyFix_nullScanIssueThrowsNpe_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(null); // will dereference scanIssue.getTitle
        assertThrows(NullPointerException.class, () -> fix.applyFix(project, descriptor));
    }
}
