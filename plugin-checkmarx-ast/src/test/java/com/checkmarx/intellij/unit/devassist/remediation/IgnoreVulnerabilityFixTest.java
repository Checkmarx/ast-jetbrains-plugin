package com.checkmarx.intellij.unit.devassist.remediation;

import com.checkmarx.intellij.CxIcons;
import com.checkmarx.intellij.devassist.ignore.IgnoreFileManager;
import com.checkmarx.intellij.devassist.model.Location;
import com.checkmarx.intellij.devassist.model.ScanIssue;
import com.checkmarx.intellij.devassist.problems.ProblemHolderService;
import com.checkmarx.intellij.devassist.remediation.IgnoreVulnerabilityFix;
import com.checkmarx.intellij.devassist.utils.DevAssistConstants;
import com.intellij.codeInspection.ProblemDescriptor;
import com.intellij.notification.NotificationGroup;
import com.intellij.notification.NotificationGroupManager;
import com.intellij.openapi.application.Application;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Iconable;
import org.junit.jupiter.api.*;
import org.mockito.MockedStatic;

import javax.swing.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class IgnoreVulnerabilityFixTest {

    private Project project;
    private ProblemDescriptor descriptor;
    private ScanIssue issue;
    private IgnoreFileManager ignoreFileManager;
    private ProblemHolderService problemHolderService;
    private MockedStatic<IgnoreFileManager> ignoreFileManagerStatic;
    private MockedStatic<ProblemHolderService> problemHolderServiceStatic;

    static MockedStatic<ApplicationManager> appManagerMock;
    static Application mockApp;
    static MockedStatic<NotificationGroupManager> notificationGroupManagerMock;
    static NotificationGroupManager mockNotificationGroupManager;
    static NotificationGroup mockNotificationGroup;

    @BeforeAll
    static void setupStaticMocks() {
        // Mock ApplicationManager.getApplication()
        mockApp = mock(Application.class, RETURNS_DEEP_STUBS);
        appManagerMock = mockStatic(ApplicationManager.class, CALLS_REAL_METHODS);
        appManagerMock.when(ApplicationManager::getApplication).thenReturn(mockApp);

        // Mock NotificationGroupManager.getInstance()
        mockNotificationGroupManager = mock(NotificationGroupManager.class, RETURNS_DEEP_STUBS);
        notificationGroupManagerMock = mockStatic(NotificationGroupManager.class, CALLS_REAL_METHODS);
        notificationGroupManagerMock.when(NotificationGroupManager::getInstance).thenReturn(mockNotificationGroupManager);

        // Mock NotificationGroup
        mockNotificationGroup = mock(NotificationGroup.class, RETURNS_DEEP_STUBS);
        when(mockNotificationGroupManager.getNotificationGroup(anyString())).thenReturn(mockNotificationGroup);
    }

    @AfterAll
    static void tearDownStaticMocks() {
        if (appManagerMock != null) appManagerMock.close();
        if (notificationGroupManagerMock != null) notificationGroupManagerMock.close();
    }

    @BeforeEach
    void setUp(){
        project = mock(Project.class, RETURNS_DEEP_STUBS);
        descriptor = mock(ProblemDescriptor.class);
        issue = new ScanIssue();
        issue.setTitle("Vuln Title");
        issue.setFilePath("/test/path/file.js");
        issue.setScanEngine(com.checkmarx.intellij.devassist.utils.ScanEngine.OSS);
        issue.setPackageManager("npm");
        issue.setPackageVersion("1.0.0");
        // Add a location to avoid IndexOutOfBoundsException
        issue.setLocations(List.of(new Location(10, 0, 20)));

        // Mock the services that IgnoreManager depends on
        ignoreFileManager = mock(IgnoreFileManager.class);
        problemHolderService = mock(ProblemHolderService.class);

        // Mock normalizePath to return a simple relative path
        when(ignoreFileManager.normalizePath(anyString())).thenReturn("file.js");
        // Mock getIgnoreData to return an empty map
        when(ignoreFileManager.getIgnoreData()).thenReturn(new HashMap<>());

        ignoreFileManagerStatic = mockStatic(IgnoreFileManager.class);
        ignoreFileManagerStatic.when(() -> IgnoreFileManager.getInstance(project)).thenReturn(ignoreFileManager);

        problemHolderServiceStatic = mockStatic(ProblemHolderService.class);
        problemHolderServiceStatic.when(() -> ProblemHolderService.getInstance(project)).thenReturn(problemHolderService);
    }

    @AfterEach
    void tearDown() {
        if (ignoreFileManagerStatic != null) {
            ignoreFileManagerStatic.close();
        }
        if (problemHolderServiceStatic != null) {
            problemHolderServiceStatic.close();
        }
    }

    @Test
    @DisplayName("Constructor creates instance with non-null ScanIssue")
    void testConstructor_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        assertNotNull(fix);
    }

    @Test
    @DisplayName("Constructor stores scanIssue field (reflection identity)")
    void testConstructor_storesScanIssue_functionality() throws Exception {
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        Field f = IgnoreVulnerabilityFix.class.getDeclaredField("scanIssue");
        f.setAccessible(true);
        assertSame(issue, f.get(fix));
    }

    @Test
    @DisplayName("getFamilyName returns expected constant")
    void testGetFamilyName_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        assertEquals(DevAssistConstants.IGNORE_THIS_VULNERABILITY_FIX_NAME, fix.getFamilyName());
    }

    @Test
    @DisplayName("getIcon returns STAR_ACTION for visibility flag")
    void testGetIcon_visibilityFlag_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        Icon icon = fix.getIcon(Iconable.ICON_FLAG_VISIBILITY);
        assertNotNull(icon); assertEquals(CxIcons.STAR_ACTION, icon);
    }

    @Test
    @DisplayName("getIcon returns STAR_ACTION for combined flags")
    void testGetIcon_combinedFlags_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        int flags = Iconable.ICON_FLAG_READ_STATUS | Iconable.ICON_FLAG_VISIBILITY;
        Icon icon = fix.getIcon(flags);
        assertNotNull(icon); assertEquals(CxIcons.STAR_ACTION, icon);
    }

    @Test
    @DisplayName("applyFix logs info without throwing when title present")
    void testApplyFix_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        assertDoesNotThrow(() -> fix.applyFix(project, descriptor));
    }

    @Test
    @DisplayName("applyFix handles null title gracefully")
    void testApplyFix_nullTitle_functionality(){
        issue.setTitle(null);
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(issue);
        assertDoesNotThrow(() -> fix.applyFix(project, descriptor));
    }

    @Test
    @DisplayName("applyFix throws NullPointerException when scanIssue is null")
    void testApplyFix_nullScanIssueThrowsNpe_functionality(){
        IgnoreVulnerabilityFix fix = new IgnoreVulnerabilityFix(null); // will dereference scanIssue.getTitle
        assertThrows(NullPointerException.class, () -> fix.applyFix(project, descriptor));
    }
}
